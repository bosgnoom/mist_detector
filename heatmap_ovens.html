<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v5.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<!-- Create a div where the selectors are placed -->
<div id="selectors">
    <form>
        <table>
            <tr>
                <td>Type 1</td>
                <td>Type 2</td>
                <td>Type 3</td>
                <td>Grade</td>
                <td>Thickness</td>
                <td>Width</td>
            </tr>
            <tr>
                <td><select id="type1"></select></td>
                <td><select id="type2"></select></td>
                <td><select id="type3"></select></td>
                <td><select id="grade"></select></td>
                <td><select id="thickness"></select></td>
                <td><select id="width"></select></td>
                <td><input type="reset" value="reset" onclick="reset_form()"></td>
            </tr>
        </table>
    </form>
</div>

<!-- Create a div where the loss function is placed -->
<div id='loss'></div>

<!-- Load color palettes -->
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<!-- Load data -->
<script src="gegevens.js"></script>

<!-- Heatmap script-->
<script>
    // Set the dimensions and margins of the graph
    var margin = { top: 80, right: 25, bottom: 30, left: 50 },
        width = (0.8 * window.innerWidth) - margin.left - margin.right,
        height = (0.8 * window.innerHeight) - margin.top - margin.bottom;

    // Append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

    // Add title to graph
    svg.append("text")
        .attr("x", 0)
        .attr("y", -50)
        .attr("text-anchor", "left")
        .style("font-size", "22px")
        .text("Production and yield heatmap");

    // Add subtitle to graph
    svg.append("text")
        .attr("x", 0)
        .attr("y", -20)
        .attr("text-anchor", "left")
        .style("font-size", "14px")
        .style("fill", "grey")
        .style("max-width", 400)
        .text("Grootte = totale aantal kilo's, kleur = yield");

    // Will be used to hold the selected product
    var keuzes = {
        "type1": "All",
        "type2": "All",
        "type3": "All",
        "grade": "All",
        "thickness": "All",
        "width": "All"
    };

    // Prepare X scale and axis:
    var x = d3.scaleBand()
        .padding(0.05)
        .range([0, width]);

    var xAxis = svg.append("g")
        .style("font-size", 15)
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    // Prepare Y scale and axis:
    var y = d3.scaleBand()
        .padding(0.05)
        .range([height, 0]);

    var yAxis = svg.append("g")
        .style("font-size", 15)
        .call(d3.axisLeft(y));

    // Prepare Z scale (radius is a measure for amount)
    let z = d3.scaleSqrt();

    // Build color scale (color is a measure for yield)
    var myColor = d3.scaleLinear()
        .domain([0.7, 0.85, 1.0])
        .range(['red', 'orange', 'green']);

    // Create tooltip (hover over cirlce)
    var tooltip = d3.select("#my_dataviz")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px")
        .style("position", "fixed");

    // Three function that change the tooltip when user hover / move / leave a cell
    var mouseover = function (d) {
        tooltip
            .style("opacity", 1)
        d3.select(this)
            .style("stroke", "black")
            .style("opacity", 1)
    }
    var mousemove = function (d) {
        tooltip
            .html("Yield: " + Math.round(1000 * (d.FO_OUT / d.FO_IN)) / 10 + "%" + "<br>" + "Production: " + Math.round(d.FO_OUT) + " kg")
            .style("left", (d3.mouse(this)[0] + 80) + "px")
            .style("top", (d3.mouse(this)[1] + 70) + "px");
    }
    var mouseleave = function (d) {
        tooltip
            .style("opacity", 0)
        d3.select(this)
            .style("stroke", "none")
            .style("opacity", 0.8)
    }

    // Update function for graph, draw circles
    function update_graph(geselecteerd) {
        console.log("Update functie aangeroepen");

        // Distill which data to show
        selection = new Array();
        gegevens.forEach(function (d) {
            if (
                (d["Type 1"] == geselecteerd.type1 || geselecteerd.type1 == "All") &&
                (d["Type 2"] == geselecteerd.type2 || geselecteerd.type2 == "All") &&
                (d["Type 3"] == geselecteerd.type3 || geselecteerd.type3 == "All") &&
                (d["Grade"] == geselecteerd.grade || geselecteerd.grade == "All") &&
                (d["Thickness"] == geselecteerd.thickness || geselecteerd.thickness == "All") &&
                (d["Width"] == geselecteerd.width || geselecteerd.width == "All")) {

                // Product matches selection
                selection.push(d);
            }
        });

        // Type 1 knop
        // Remove all items from dropdown list
        document.getElementById('type1').options.length = 0;

        // Get types 1 from selection
        var type1 = d3.map(gegevens, function (d) {
            return d['Type 1'];
        }).keys().sort();
        
        // Include "All" if needed
        if (geselecteerd.type1 == "All") {
            type1.unshift('All');
        }

        // Initialize the button
        d3.select('#type1')
            .selectAll()
            .data(type1)
            .enter()
            .append('option')
            .text(function (d) { return d; })
            .attr("value", function (d) { return d; });

        // Add onchange event to button
        d3.select('#type1')
            .on("change", function (d) { // When button changes, run update function
                keuzes.type1 = d3.select(this).property("value");
                update_graph(keuzes);
            });

        // Type 2 knop
        // Type 2 uit de gegevens halen
        document.getElementById('type2').options.length = 0;
        var type2 = d3.map(selection, function (d) {
            return d['Type 2'];
        }).keys().sort();

        // All toevoegen aan het begin van de array (unshift)
        type2.unshift('All');

        // Initialize the button
        d3.select('#type2')
            .selectAll()
            .data(type2)
            .enter()
            .append('option')
            .text(function (d) { return d; })
            .attr("value", function (d) { return d; });

        d3.select('#type2')
            .on("change", function (d) { // When button changes, run update function
                type2_selectie = d3.select(this).property("value");
                console.log("Nu verandert type 2 naar: " + type2_selectie);
                keuzes.type2 = type2_selectie;
                update_graph(keuzes);
            });

        // Type 3 knop
        document.getElementById('type3').options.length = 0;
        var type3 = d3.map(selection, function (d) {
            return d['Type 3'];
        }).keys().sort();
        type3.unshift('All');

        // Initialize the button
        d3.select('#type3')
            .selectAll()
            .data(type3)
            .enter()
            .append('option')
            .text(function (d) { return d; })
            .attr("value", function (d) { return d; });

        d3.select('#type3')
            .on("change", function (d) { // When button changes, run update function
                keuzes.type3 = d3.select(this).property("value");
                update_graph(keuzes);
            });

        // Grade knop
        document.getElementById('grade').options.length = 0;
        var grade = d3.map(selection, function (d) {
            return d['Grade'];
        }).keys().sort((a, b) => a - b);
        grade.unshift('All');

        // Initialize the button
        d3.select('#grade')
            .selectAll()
            .data(grade)
            .enter()
            .append('option')
            .text(function (d) { return d; })
            .attr("value", function (d) { return d; });

        d3.select('#grade')
            .on("change", function (d) { // When button changes, run update function
                keuzes.grade = d3.select(this).property("value");
                update_graph(keuzes);
            });

        // Thickness knop
        document.getElementById('thickness').options.length = 0;
        var thickness = d3.map(selection, function (d) {
            return d['Thickness'];
        }).keys().sort((a, b) => a - b);
        thickness.unshift('All');

        // Initialize the button
        d3.select('#thickness')
            .selectAll()
            .data(thickness)
            .enter()
            .append('option')
            .text(function (d) { return d; })
            .attr("value", function (d) { return d; });

        d3.select('#thickness')
            .on("change", function (d) { // When button changes, run update function
                keuzes.thickness = d3.select(this).property("value");
                update_graph(keuzes);
            });

        // width knop
        document.getElementById('width').options.length = 0;
        var product_width = d3.map(selection, function (d) {
            return d['Width'];
        }).keys().sort((a, b) => a - b);
        product_width.unshift('All');

        // Initialize the button
        d3.select('#width')
            .selectAll()
            .data(product_width)
            .enter()
            .append('option')
            .text(function (d) { return d; })
            .attr("value", function (d) { return d; });

        d3.select('#width')
            .on("change", function (d) { // When button changes, run update function
                keuzes.width = d3.select(this).property("value");
                update_graph(keuzes);
            });

        // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
        myGroups = d3.map(selection, function (d) { return d.XT; }).keys().sort()        // XT
        myVars = d3.map(selection, function (d) { return d.Workcenter; }).keys().sort()  // FO

        // Fill data (array of dicts) 
        // Eerst een lege array of dicts bouwen (kan dit niet beter???)
        data = [];
        myGroups.forEach(function (d) {
            myVars.forEach(function (e) {
                data.push({
                    "id": d + "-" + e,
                    "Workcenter": e,
                    "XT": d,
                    "FO_IN": 0,
                    "FO_OUT": 0,
                });
            })
        })

        // Nu de array vullen, op basis van een id
        selection.forEach(function (d) {
            //console.log(d);
            let id = d.XT + "-" + d.Workcenter;
            data.find(function (p) {
                if (p.id == id) {
                    p.FO_IN += d.FO_IN;
                    p.FO_OUT += d.FO_OUT;
                }
            })
        });

        // Refresh X scales and axis:
        x.domain(myGroups);
        xAxis
            .transition()
            .duration(1000)
            .call(d3.axisBottom(x));

        // Refresh Y scales and axis:
        y.domain(myVars);
        yAxis
            .transition()
            .duration(1000)
            .call(d3.axisLeft(y))

        // Build value scale:
        let z_values = data.map(d => d.FO_OUT);
        let z_scale = Math.max(...z_values);
        let z = d3.scaleSqrt()
            .domain([0, z_scale])  // Nog als min/max uitvoeren
            .range([5, 0.5 * Math.min(x.bandwidth(), y.bandwidth())]);

        // Loss function
        var yields = data.map(
            function (el) {
                let yield = 0;
                if (el.FO_IN > 0) { yield = el.FO_OUT / el.FO_IN; }
                return yield;
            });
        let yield_max = Math.max(...yields);
        let yield_min = Math.min(...yields);
        console.log("Max yield: " + yield_max);
        if (yield_max > 1) { yield_max = 0.99 };

        let loss = data.map(function (d) {
            let yield_verschil = 0;
            if (d.FO_IN > 0) { yield_verschil = yield_max - (d.FO_OUT / d.FO_IN); }
            verlies = yield_verschil * d.FO_OUT;
            return verlies
        });
        let loss_total = loss.reduce((a, b) => a + b, 0);

        d3.selectAll('#loss')
            .text("Beste yield: " + Math.round(1000 * yield_max) / 10 + "%, verlies: " + Math.round(loss_total / 1000) + " ton wegens routing verschil");

        console.log(loss_total);


        const t = svg.transition()
            .duration(1000);

        // update graph
        var svg_update = svg
            .selectAll("circle")
            .data(data, function (d) { return d.XT + ':' + d.Workcenter; })
            .join(
                enter => enter.append("circle")
                    .attr("cx", 0)
                    .attr("cy", height)
                    .attr("r", 0)
                    .style("stroke-width", 4)
                    .style("stroke", "none")
                    .style("opacity", 0.8)
                    .on("mouseover", mouseover)
                    .on("mousemove", mousemove)
                    .on("mouseleave", mouseleave)
                    .call(enter => enter.transition(t)
                        .attr("cx", function (d) { return x(d.XT) + x.bandwidth() / 2 })
                        .attr("cy", function (d) { return y(d.Workcenter) + y.bandwidth() / 2 })
                        .style("fill", function (d) { return myColor(clamp(d.FO_OUT / d.FO_IN, 0.7, 1)) })
                        .attr("r", function (d) { return z(d.FO_OUT) })),
                update => update
                    .call(update => update.transition(t)
                        .attr("cx", function (d) { return x(d.XT) + x.bandwidth() / 2 })
                        .attr("cy", function (d) { return y(d.Workcenter) + y.bandwidth() / 2 })
                        .style("fill", function (d) { return myColor(clamp((d.FO_OUT / d.FO_IN), 0.7, 1)) })
                        .attr("r", function (d) { return z(d.FO_OUT) })),
                exit => exit
                    .call(exit => exit.transition(t)
                        .attr("cx", width)
                        .attr("cy", height)
                        .attr("r", 0)
                        .remove())
            );

        var opruimen = svg
            .selectAll("circle")
            .filter(function (d) { return d.FO_OUT == 0 })
            .remove();


    }

    // Catch resize of window ** not implemented yet ***
    window.onresize = function () {
        console.log("Resized...");
        width = (0.8 * window.innerWidth) - margin.left - margin.right;
        height = (0.8 * window.innerHeight) - margin.top - margin.bottom;

    };

    // Limit values to clamp values
    function clamp(val, min, max) {
        return val > max ? max : val < min ? min : val;
    }

    // Reset heatmap to All
    function reset_form() {
        keuzes = {
            "type1": "All",
            "type2": "All",
            "type3": "All",
            "grade": "All",
            "thickness": "All",
            "width": "All"
        };
        update_graph(keuzes);
    }

    // Call update_graph for the first time, to show all data
    update_graph(keuzes);

</script>