<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v5.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<!-- Create a div where the selectors are placed -->
<div id="selectors">
    <form>
        <table>
            <tr>
                <td>Type 1</td>
                <td>Type 2</td>
                <td>Type 3</td>
                <td>Grade</td>
                <td>Thickness</td>
                <td>Width</td>
            </tr>
            <tr>
                <td><select id="type1"></select></td>
                <td><select id="type2"></select></td>
                <td><select id="type3"></select></td>
                <td><select id="grade"></select></td>
                <td><select id="thickness"></select></td>
                <td><select id="width"></select></td>
                <td><input type="reset" value="reset" onclick="reset_form()"></td>
            </tr>
        </table>
    </form>
</div>

<!-- Create a div where the loss function is placed -->
<div id='loss'></div>

<!-- Load color palettes -->
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<!-- Load data -->
<script src="gegevens.js"></script>

<!-- Heatmap script-->
<script>
    // set the dimensions and margins of the graph
    var margin = { top: 80, right: 25, bottom: 30, left: 50 },
        width = (0.8 * window.innerWidth) - margin.left - margin.right,
        height = (0.8 * window.innerHeight) - margin.top - margin.bottom;

    // Append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

    // Add title to graph
    svg.append("text")
        .attr("x", 0)
        .attr("y", -50)
        .attr("text-anchor", "left")
        .style("font-size", "22px")
        .text("Production and yield heatmap");

    // Add subtitle to graph
    svg.append("text")
        .attr("x", 0)
        .attr("y", -20)
        .attr("text-anchor", "left")
        .style("font-size", "14px")
        .style("fill", "grey")
        .style("max-width", 400)
        .text("Grootte = totale aantal kilo's, kleur = yield");

    // Will be used to hold the selected product
    var keuzes = {
        "type1": "All",
        "type2": "All",
        "type3": "All",
        "grade": "All",
        "thickness": "All",
        "width": "All"
    };

    var selection = gegevens;

    // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
    var myGroups = d3.map(selection, function (d) { return d.XT; }).keys().sort()        // XT
    var myVars = d3.map(selection, function (d) { return d.Workcenter; }).keys().sort()  // FO

    // Fill data (array of dicts) 
    // Eerst een lege array of dicts bouwen (kan dit niet beter???)
    let data = [];
    myGroups.forEach(function (d) {
        myVars.forEach(function (e) {
            data.push({
                "id": d + "-" + e,
                "Workcenter": e,
                "XT": d,
                "FO_IN": 0,
                "FO_OUT": 0,
            });
        })
    })

    // Nu de array vullen, op basis van een id
    selection.forEach(function (d) {
        //console.log(d);
        let id = d.XT + "-" + d.Workcenter;
        data.find(function (p) {
            if (p.id == id) {
                p.FO_IN += Math.round(d.FO_IN);
                p.FO_OUT += Math.round(d.FO_OUT);
            }
        })
    });
    //console.log(data);

    // Build X scales and axis:
    var x = d3.scaleBand()
        .range([0, width])
        .domain(myGroups)
        .padding(0.05);

    var xAxis = svg.append("g")
        .style("font-size", 15)
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    // Build Y scales and axis:
    var y = d3.scaleBand()
        .range([height, 0])
        .domain(myVars)
        .padding(0.05);

    var yAxis = svg.append("g")
        .style("font-size", 15)
        .call(d3.axisLeft(y));

    // Build value scale:
    let z_values = data.map(d => d.FO_OUT);
    let z_scale = Math.max(...z_values);
    let z = d3.scaleSqrt()
        .domain([0, z_scale])
        .range([5, 0.5 * Math.min(x.bandwidth(), y.bandwidth())]);
    //console.log(y.bandwidth());

    // Minimum en maximum opzoeken
    var yields = data.map(
        function (el) {
            let yield = 0;
            if (el.FO_IN > 0) { yield = el.FO_OUT / el.FO_IN; }
            return yield;
        });
    //console.log(yields);
    var yield_min = Math.max(Math.min(...yields), 0.70);   // Limit yield to 75%
    var yield_max = Math.min(Math.max(...yields), 1);      // Limit yield to 100%
    console.log(yield_min);
    console.log(yield_max);
    // Build color scale
    var myColor = d3.scaleLinear()
        .domain([yield_min, (yield_min + yield_max) / 2, yield_max])
        .range(['red', 'orange', 'green']);

    // create a tooltip
    var tooltip = d3.select("#my_dataviz")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px")
        .style("position", "fixed")

    // Three function that change the tooltip when user hover / move / leave a cell
    var mouseover = function (d) {
        tooltip
            .style("opacity", 1)
        d3.select(this)
            .style("stroke", "black")
            .style("opacity", 1)
    }
    var mousemove = function (d) {
        tooltip
            .html("Yield: " + Math.round(1000 * (d.FO_OUT / d.FO_IN)) / 10 + "%" + "<br>" + "Som FO_OUT: " + Math.round(d.FO_OUT) + " kg")
            .style("left", (d3.mouse(this)[0] + 80) + "px")
            .style("top", (d3.mouse(this)[1] + 70) + "px");
    }
    var mouseleave = function (d) {
        tooltip
            .style("opacity", 0)
        d3.select(this)
            .style("stroke", "none")
            .style("opacity", 0.8)
    }

    // add the circles
    svg.selectAll("circle")
        .data(data, function (d) { return d.XT + ':' + d.Workcenter; })
        .enter()
        .append("circle")
        .filter(function (d) { return d.FO_OUT > 0 })
        .attr("cx", function (d) { return x(d.XT) + x.bandwidth() / 2 })
        .attr("cy", function (d) { return y(d.Workcenter) + y.bandwidth() / 2 })
        .attr("r", function (d) { return z(d.FO_OUT) })
        .style("fill", function (d) { return myColor(clamp((d.FO_OUT / d.FO_IN), 0.7, 1)) })
        .style("stroke-width", 4)
        .style("stroke", "none")
        .style("opacity", 0.8)
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)

    // Type 1 knop
    // Type 1 uit de gegevens halen
    var type1 = d3.map(gegevens, function (d) {
        return d['Type 1'];
    }).keys().sort();

    // All toevoegen aan het begin van de array (unshift)
    type1.unshift('All');

    // Initialize the button
    d3.select('#type1')
        .selectAll()
        .data(type1)
        .enter()
        .append('option')
        .text(function (d) { return d; })
        .attr("value", function (d) { return d; });

    d3.select('#type1')
        .on("change", function (d) { // When button changes, run update function
            type1_selectie = d3.select(this).property("value");
            console.log("Nu verandert type 1 naar: " + type1_selectie);
            keuzes.type1 = type1_selectie;
            update_graph(keuzes);
        });

    // Type 2 knop
    // Type 2 uit de gegevens halen
    var type2 = d3.map(gegevens, function (d) {
        return d['Type 2'];
    }).keys().sort();

    // All toevoegen aan het begin van de array (unshift)
    type2.unshift('All');

    // Initialize the button
    d3.select('#type2')
        .selectAll()
        .data(type2)
        .enter()
        .append('option')
        .text(function (d) { return d; })
        .attr("value", function (d) { return d; });

    d3.select('#type2')
        .on("change", function (d) { // When button changes, run update function
            type2_selectie = d3.select(this).property("value");
            console.log("Nu verandert type 2 naar: " + type2_selectie);
            keuzes.type2 = type2_selectie;
            update_graph(keuzes);
        });

    // Type 3 knop
    var type3 = d3.map(gegevens, function (d) {
        return d['Type 3'];
    }).keys().sort();
    type3.unshift('All');

    // Initialize the button
    d3.select('#type3')
        .selectAll()
        .data(type3)
        .enter()
        .append('option')
        .text(function (d) { return d; })
        .attr("value", function (d) { return d; });

    d3.select('#type3')
        .on("change", function (d) { // When button changes, run update function
            keuzes.type3 = d3.select(this).property("value");
            update_graph(keuzes);
        });

    // Grade knop
    var grade = d3.map(gegevens, function (d) {
        return d['Grade'];
    }).keys().sort((a, b) => a - b);
    grade.unshift('All');

    // Initialize the button
    d3.select('#grade')
        .selectAll()
        .data(grade)
        .enter()
        .append('option')
        .text(function (d) { return d; })
        .attr("value", function (d) { return d; });

    d3.select('#grade')
        .on("change", function (d) { // When button changes, run update function
            keuzes.grade = d3.select(this).property("value");
            update_graph(keuzes);
        });

    // Thickness knop
    var thickness = d3.map(gegevens, function (d) {
        return d['Thickness'];
    }).keys().sort((a, b) => a - b);
    thickness.unshift('All');

    // Initialize the button
    d3.select('#thickness')
        .selectAll()
        .data(thickness)
        .enter()
        .append('option')
        .text(function (d) { return d; })
        .attr("value", function (d) { return d; });

    d3.select('#thickness')
        .on("change", function (d) { // When button changes, run update function
            keuzes.thickness = d3.select(this).property("value");
            update_graph(keuzes);
        });

    // width knop
    var product_width = d3.map(gegevens, function (d) {
        return d['Width'];
    }).keys().sort((a, b) => a - b);
    product_width.unshift('All');

    // Initialize the button
    d3.select('#width')
        .selectAll()
        .data(product_width)
        .enter()
        .append('option')
        .text(function (d) { return d; })
        .attr("value", function (d) { return d; });

    d3.select('#width')
        .on("change", function (d) { // When button changes, run update function
            keuzes.width = d3.select(this).property("value");
            update_graph(keuzes);
        });



    function update_graph(geselecteerd) {
        console.log("Update functie aangeroepen");
        console.log(geselecteerd);



        // Distill which gegevens to show // Replace with filter function sometimes?
        selection = new Array();
        gegevens.forEach(function (d) {
            if (
                (d["Type 1"] == geselecteerd["type1"] || geselecteerd["type1"] == "All") &&
                (d["Type 2"] == geselecteerd.type2 || geselecteerd.type2 == "All") &&
                (d["Type 3"] == geselecteerd.type3 || geselecteerd.type3 == "All") &&
                (d["Grade"] == geselecteerd.grade || geselecteerd.grade == "All") &&
                (d["Thickness"] == geselecteerd.thickness || geselecteerd.thickness == "All") &&
                (d["Width"] == geselecteerd.width || geselecteerd.width == "All")) {
                // Types matchen
                selection.push(d);
                //console.log(d);
            }
        });

        // Clear type2 select list
        document.getElementById('type2').options.length = 0;
        type2 = d3.map(selection, function (d) {
            return d['Type 2'];
        }).keys().sort();
        type2.unshift('All');
        d3.select('#type2')
            .selectAll()
            .data(type2)
            .enter()
            .append('option')
            .text(function (d) { return d; })
            .attr("value", function (d) { return d; });
        console.log(type2);

        // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
        myGroups = d3.map(selection, function (d) { return d.XT; }).keys().sort()        // XT
        myVars = d3.map(selection, function (d) { return d.Workcenter; }).keys().sort()  // FO

        // Fill data (array of dicts) 
        // Eerst een lege array of dicts bouwen (kan dit niet beter???)
        data = [];
        myGroups.forEach(function (d) {
            myVars.forEach(function (e) {
                data.push({
                    "id": d + "-" + e,
                    "Workcenter": e,
                    "XT": d,
                    "FO_IN": 0,
                    "FO_OUT": 0,
                });
            })
        })

        // Nu de array vullen, op basis van een id
        selection.forEach(function (d) {
            //console.log(d);
            let id = d.XT + "-" + d.Workcenter;
            data.find(function (p) {
                if (p.id == id) {
                    p.FO_IN += d.FO_IN;
                    p.FO_OUT += d.FO_OUT;
                }
            })
        });

        // Refresh X scales and axis:
        x.domain(myGroups);
        xAxis
            .transition()
            .duration(1000)
            .call(d3.axisBottom(x));

        // Refresh Y scales and axis:
        y.domain(myVars);
        yAxis
            .transition()
            .duration(1000)
            .call(d3.axisLeft(y))

        // Build value scale:
        let z_values = data.map(d => d.FO_OUT);
        let z_scale = Math.max(...z_values);
        let z = d3.scaleSqrt()
            .domain([0, z_scale])  // Nog als min/max uitvoeren
            .range([5, 0.5 * Math.min(x.bandwidth(), y.bandwidth())]);

        // Loss function
        var yields = data.map(
            function (el) {
                let yield = 0;
                if (el.FO_IN > 0) { yield = el.FO_OUT / el.FO_IN; }
                return yield;
            });
        let yield_max = Math.max(...yields);
        let yield_min = Math.min(...yields);
        console.log("Max yield: " + yield_max);
        if (yield_max > 1) { yield_max = 0.99 };

        let loss = data.map(function (d) {
            let yield_verschil = 0;
            if (d.FO_IN > 0) { yield_verschil = yield_max - (d.FO_OUT / d.FO_IN); }
            verlies = yield_verschil * d.FO_OUT;
            return verlies
        });
        let loss_total = loss.reduce((a, b) => a + b, 0);

        d3.selectAll('#loss')
            .text("Beste yield: " + Math.round(1000 * yield_max) / 10 + "%, verlies: " + Math.round(loss_total / 1000) + " ton wegens routing verschil");

        console.log(loss_total);


        const t = svg.transition()
            .duration(1000);

        // update graph
        var svg_update = svg
            .selectAll("circle")
            .data(data, function (d) { return d.XT + ':' + d.Workcenter; })
            .join(
                enter => enter.append("circle")
                    .attr("cx", 0)
                    .attr("cy", height)
                    .attr("r", 0)
                    .style("stroke-width", 4)
                    .style("stroke", "none")
                    .style("opacity", 0.8)
                    .on("mouseover", mouseover)
                    .on("mousemove", mousemove)
                    .on("mouseleave", mouseleave)
                    .call(enter => enter.transition(t)
                        .attr("cx", function (d) { return x(d.XT) + x.bandwidth() / 2 })
                        .attr("cy", function (d) { return y(d.Workcenter) + y.bandwidth() / 2 })
                        .style("fill", function (d) { return myColor(clamp(d.FO_OUT / d.FO_IN, 0.7, 1)) })
                        .attr("r", function (d) { return z(d.FO_OUT) })),
                update => update
                    .call(update => update.transition(t)
                        .attr("cx", function (d) { return x(d.XT) + x.bandwidth() / 2 })
                        .attr("cy", function (d) { return y(d.Workcenter) + y.bandwidth() / 2 })
                        .style("fill", function (d) { return myColor(clamp((d.FO_OUT / d.FO_IN), 0.7, 1)) })
                        .attr("r", function (d) { return z(d.FO_OUT) })),
                exit => exit
                    .call(exit => exit.transition(t)
                        .attr("cx", width)
                        .attr("cy", height)
                        .attr("r", 0)
                        .remove())
            );

        var opruimen = svg
            .selectAll("circle")
            .filter(function (d) { return d.FO_OUT == 0 })
            .remove();


    }

    // Catch resize of window
    window.onresize = function () {
        console.log("Resized...");
        width = (0.8 * window.innerWidth) - margin.left - margin.right;
        height = (0.8 * window.innerHeight) - margin.top - margin.bottom;

    };

    // Limit values to clamp values
    function clamp(val, min, max) {
        return val > max ? max : val < min ? min : val;
    }

    // Reset heatmap to All
    function reset_form() {
        keuzes = {
            "type1": "All",
            "type2": "All",
            "type3": "All",
            "grade": "All",
            "thickness": "All",
            "width": "All"
        };
        update_graph(keuzes);
    }

</script>